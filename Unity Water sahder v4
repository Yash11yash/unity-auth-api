Shader "Custom/StylizedWaterWithWind_Improved_V5_WakeEffect"
{
    Properties
    {
        _Color("Water Color", Color) = (0,0.5,1,1)
        _WaveSpeed("Wave Speed", Float) = 1.0
        _WaveStrength("Wave Strength", Float) = 0.1
        _WindDirection("Wind Direction (XZ for waves)", Vector) = (1,0,0,0)
        _NormalTex("Normal Map (Small Scale)", 2D) = "bump" {}
        _NormalTex2("Normal Map (Large Scale)", 2D) = "bump" {}
        _NormalScale("Normal Scale", Float) = 1.0
        _Shininess("Shininess", Range(1, 100)) = 20
        _SpecularColor("Specular Color", Color) = (1,1,1,1)
        _NormalTexSpeed("Normal Map Scroll Speed", Float) = 0.05
        _NormalTexSpeed2("Normal Map 2 Scroll Speed", Float) = 0.02
        _Transparency("Overall Transparency", Range(0,1)) = 0.8
        _FresnelStrength("Fresnel Strength", Range(0,1)) = 0.5
        _FresnelPower("Fresnel Power", Range(1,10)) = 3.0

        // --- Wake/Ripple Effect Properties ---
        _WakeOrigin("Wake Origin (World XZ)", Vector) = (0,0,0,0) // New: World XZ position of the object
        _WakeRadius("Wake Radius", Float) = 5.0 // New: How far the wake extends
        _WakeStrength("Wake Strength", Float) = 0.2 // New: How strong the wake displacement is
        _WakeSpeed("Wake Spread Speed", Float) = 3.0 // New: How fast the wake ripples spread
        _WakeFoamColor("Wake Foam Color", Color) = (1,1,1,1) // New: Color of foam in wake
        _WakeFoamPower("Wake Foam Power", Range(1,10)) = 2.0 // New: How concentrated the wake foam is
    }
    SubShader
    {
        Tags { "RenderType"="Transparent" "Queue"="Transparent" }
        LOD 200

        Pass
        {
            Blend SrcAlpha OneMinusSrcAlpha
            ZWrite Off
            ZTest LEqual

            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #pragma multi_compile_fwdbase
            #pragma multi_compile_fog // Fog is enabled

            #include "UnityCG.cginc"
            #include "Lighting.cginc"

            fixed4 _Color;
            float _WaveSpeed;
            float _WaveStrength;
            float4 _WindDirection;
            sampler2D _NormalTex;
            sampler2D _NormalTex2;
            float _NormalScale;
            float _Shininess;
            fixed4 _SpecularColor;
            float _NormalTexSpeed;
            float _NormalTexSpeed2;
            float _Transparency;
            float _FresnelStrength;
            float _FresnelPower;

            // --- Wake/Ripple Effect Variables ---
            float4 _WakeOrigin;
            float _WakeRadius;
            float _WakeStrength;
            float _WakeSpeed;
            fixed4 _WakeFoamColor;
            float _WakeFoamPower;

            struct appdata
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float2 uv : TEXCOORD0;
                float4 tangent : TANGENT;
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float2 uv : TEXCOORD0;
                float2 uv2 : TEXCOORD1;
                float3 worldPos : TEXCOORD2;
                float3 worldNormal : TEXCOORD3;
                float3 worldTangent : TEXCOORD4;
                float3 worldBinormal : TEXCOORD5;
                float3 viewDir : TEXCOORD6;
                float wakeFactor : TEXCOORD7; // New: Pass wake factor for fragment shader
                UNITY_FOG_COORDS(8) // Adjusted TEXCOORD index
            };

            v2f vert(appdata v)
            {
                v2f o;

                // --- Wave displacement ---
                float wave = sin(dot(v.vertex.xz, _WindDirection.xz) * 4.0 + _Time.y * _WaveSpeed) * _WaveStrength;
                
                // --- Wake/Ripple Effect displacement (added to base wave) ---
                float2 distToWakeOrigin = v.vertex.xz - _WakeOrigin.xz; // Distance in XZ plane
                float distMagnitude = length(distToWakeOrigin); // Actual distance

                float wakeRipple = 0;
                if (distMagnitude < _WakeRadius) // Only apply wake if within radius
                {
                    // Create a circular ripple effect
                    float normalizedDist = distMagnitude / _WakeRadius;
                    float ripplePhase = (normalizedDist * 15.0 - _Time.y * _WakeSpeed); // 15.0 for more ripples
                    wakeRipple = cos(ripplePhase) * (1.0 - normalizedDist); // Falloff with distance
                    wakeRipple *= _WakeStrength; // Apply strength
                }
                
                v.vertex.y += wave + wakeRipple; // Combine base wave and wake ripple

                o.pos = UnityObjectToClipPos(v.vertex);
                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;

                o.worldNormal = UnityObjectToWorldNormal(v.normal);

                o.worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
                o.worldBinormal = cross(o.worldNormal, o.worldTangent) * v.tangent.w;

                o.uv.x = v.uv.x + _Time.y * _NormalTexSpeed;
                o.uv.y = v.uv.y;

                o.uv2.x = v.uv.x + _Time.y * _NormalTexSpeed2 * 0.7;
                o.uv2.y = v.uv.y + _Time.y * _NormalTexSpeed2 * 0.5;

                o.viewDir = WorldSpaceViewDir(v.vertex);

                // Pass wake factor to fragment shader (for foam effect)
                // Re-calculate wake ripple (without strength) to get foam intensity
                float wakeFoamIntensity = 0;
                if (distMagnitude < _WakeRadius)
                {
                    float normalizedDist = distMagnitude / _WakeRadius;
                    float ripplePhase = (normalizedDist * 15.0 - _Time.y * _WakeSpeed);
                    wakeFoamIntensity = abs(cos(ripplePhase)) * (1.0 - normalizedDist); // Use abs for foam peaks
                    wakeFoamIntensity = pow(wakeFoamIntensity, _WakeFoamPower); // Sharpen foam
                }
                o.wakeFactor = wakeFoamIntensity;


                UNITY_TRANSFER_FOG(o, o.pos);

                return o;
            }

            fixed4 frag(v2f i) : SV_Target
            {
                // --- Per-Pixel Normal Mapping with two layers ---
                fixed3 unpackedNormal1 = UnpackNormal(tex2D(_NormalTex, i.uv)).rgb;
                fixed3 unpackedNormal2 = UnpackNormal(tex2D(_NormalTex2, i.uv2)).rgb;

                fixed3 blendedUnpackedNormal = normalize(unpackedNormal1 + unpackedNormal2);
                blendedUnpackedNormal.xy *= _NormalScale;
                blendedUnpackedNormal.z = sqrt(1.0 - saturate(dot(blendedUnpackedNormal.xy, blendedUnpackedNormal.xy)));

                float3x3 TBN = float3x3(i.worldTangent, i.worldBinormal, i.worldNormal);
                float3 finalWorldNormal = normalize(mul(blendedUnpackedNormal, TBN));

                // --- Lighting ---
                float3 lightDir = normalize(_WorldSpaceLightPos0.xyz);
                float3 viewDir = normalize(i.viewDir);

                // Diffuse Lighting
                float NdotL = max(0, dot(finalWorldNormal, lightDir));
                fixed4 diffuseColor = NdotL * _LightColor0;

                // Specular Lighting (Blinn-Phong)
                float3 halfDir = normalize(lightDir + viewDir);
                float NdotH = max(0, dot(finalWorldNormal, halfDir));
                fixed4 specularColor = pow(NdotH, _Shininess) * _SpecularColor * _LightColor0;

                fixed4 finalColor = _Color * diffuseColor + specularColor + UNITY_LIGHTMODEL_AMBIENT;

                // --- Fresnel Effect ---
                float fresnel = saturate(_FresnelStrength + (1.0 - _FresnelStrength) * pow(1.0 - max(0, dot(finalWorldNormal, viewDir)), _FresnelPower));
                
                // --- Transparency ---
                finalColor.a = _Transparency;
                finalColor.a *= (1.0 - fresnel * 0.5);

                // --- Apply Wake Foam ---
                finalColor.rgb = lerp(finalColor.rgb, _WakeFoamColor.rgb, i.wakeFactor);

                UNITY_APPLY_FOG(i.fogCoord, finalColor); // Fog application
                return finalColor;
            }
            ENDCG
        }
    }
    FallBack "Diffuse"
}
